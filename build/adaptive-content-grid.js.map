{"version":3,"sources":["../src/adaptive-content-grid.jsx"],"names":["AdaptiveGridItem","ContentContainer","props","paddingTop","paddingBottom","verticalAlign","contentGap","expandableContainerRef","display","width","position","onContentResize","children","EmptyComponent","AdaptiveGrid","newChildren","map","mapChildren","style","visible","visibility","baseWidth","baseHeight","maxColumns","child","i","nodeName","attributes","minHeight","content","needsResizing","undefined","containerHeight","state","contentHeight","padding","fullHeight","Math","ceil","refs","containerRef","element","container","expandableContainer","contentChildren","finalContainer","bind","bindAll","self","window","requestAnimationFrame","forceUpdate","w","h","makeVisible","slice","clientHeight","setState","Component"],"mappings":";;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;;;;;QAESA,gB;;AAET;AACA;;AACA,SAASC,gBAAT,CAA0BC,KAA1B,EAAiC;AAC/B,MAAIC,UAAJ,EAAgBC,aAAhB;AACA,MAAIF,MAAMG,aAAN,KAAwB,QAA5B,EAAsC;AACpCF,iBAAaD,MAAMI,UAAN,GAAmB,CAAhC;AACAF,oBAAgBF,MAAMI,UAAN,GAAmB,CAAnC;AACD,GAHD,MAIK,IAAIJ,MAAMG,aAAN,KAAwB,QAA5B,EAAsC;AACzCF,iBAAaD,MAAMI,UAAnB;AACAF,oBAAgB,CAAhB;AACD,GAHI,MAIA;AACHD,iBAAa,CAAb;AACAC,oBAAgBF,MAAMI,UAAtB;AACD;AACD,SACE;AAAA;AAAA;AACE,WAAKJ,MAAMK,sBADb;AAEE,aAAO;AACLC,iBAAS,cADJ;AAELC,eAAO,MAFF;AAGLC,kBAAU,UAHL;AAILP,oBAAaA,aAAa,IAJrB;AAKLC,uBAAgBA,gBAAgB;AAL3B;AAFT;AAUE;AAAA;AAAA;AACE,eAAO;AACLI,mBAAS,cADJ;AAELC,iBAAO,MAFF;AAGLC,oBAAU;AAHL;AADT;AAOE,yDAAc,UAAUR,MAAMS,eAA9B,GAPF;AAQGT,YAAMU;AART;AAVF,GADF;AAuBD;;AAED;AACA,SAASC,cAAT,CAAwBX,KAAxB,EAA+B;AAC7B,SAAO;AAAA;AAAA;AAAOA,UAAMU;AAAb,GAAP;AACD;;AAED;;IACaE,Y,WAAAA,Y;;;;;;;;;;;6BACF;AACP,UACEC,cAAc,KAAKb,KAAL,CAAWU,QAAX,CAAoBI,GAApB,CAAwB,KAAKC,WAA7B,CADhB;AAAA,UAEEC,QAAQ,KAAKC,OAAL,GAAe,EAAf,GAAoB;AAC1BC,oBAAY;AADc,OAF9B;AAMA,aACE;AAAA;AAAA,UAAK,OAAOF,KAAZ;AACE;AAAA;AAAA;AACE,uBAAW,KAAKhB,KAAL,CAAWmB,SADxB;AAEE,wBAAY,KAAKnB,KAAL,CAAWoB,UAFzB;AAGE,wBAAY,KAAKpB,KAAL,CAAWqB;AAHzB;AAKIR;AALJ;AADF,OADF;AAWD;;;gCAEWS,K,EAAOC,C,EAAG;AACpB,UAAG,EAAE,KAAKvB,KAAL,CAAWmB,SAAX,GAAuB,CAAzB,CAAH,EACE,OAAOG,KAAP;AAEF,UAAG,EAAE,KAAKtB,KAAL,CAAWoB,UAAX,GAAwB,CAA1B,CAAH,EACE,OAAOE,KAAP;AAEF,UAAIA,MAAME,QAAN,mCAAJ,EACE,OAAOF,KAAP;AAEF,UAAI,CAACA,MAAMG,UAAX,EACE,OAAOH,KAAP;AAEF,UAAIA,MAAMG,UAAN,CAAiBC,SAAjB,KAA+B,SAAnC,EACE,OAAOJ,KAAP;AAEF,UAAI,OAAOA,MAAMG,UAAN,CAAiBE,OAAxB,KAAoC,UAAxC,EACE,OAAOL,KAAP;AAEF,UAAI,KAAKM,aAAL,KAAuBC,SAA3B,EAAsC;AACpC,aAAKD,aAAL,GAAqB,IAArB;AACA,aAAKX,OAAL,GAAe,KAAf;AACD;AACD,UACEa,kBAAkB,KAAKC,KAAL,CAAWC,aAAX,CAAyBT,CAAzB,IAA8B,KAAKQ,KAAL,CAAWE,OAAX,CAAmBV,CAAnB,CADlD;AAAA,UAGEG,YAAaI,mBAAmB,KAAK9B,KAAL,CAAWoB,UAH7C;AAAA,UAKEc,aAAaC,KAAKC,IAAL,CAAUV,YAAY,KAAK1B,KAAL,CAAWoB,UAAjC,IAA+C,KAAKpB,KAAL,CAAWoB,UALzE;AAAA,UAOEiB,OAAO,EAPT;AAAA,UASEC,eAAe,SAAfA,YAAe,CAASC,OAAT,EAAkB;AAC/BF,aAAKG,SAAL,GAAiBD,OAAjB;AACD,OAXH;AAAA,UAaElC,yBAAyB,SAAzBA,sBAAyB,CAASkC,OAAT,EAAkB;AACzCF,aAAKI,mBAAL,GAA2BF,OAA3B;AACD,OAfH;AAAA,UAiBEZ,UAAUL,MAAMG,UAAN,CAAiBE,OAAjB,CACRhB,cADQ,CAjBZ;AAAA,UAqBE+B,kBAAkBf,QAAQjB,QArB5B;AAAA,UAuBE8B,YACE;AAAC,wBAAD;AAAA;AACE,kCAAwBnC,sBAD1B;AAEE,sBAAY6B,aAAaR,SAF3B;AAGE,yBAAeJ,MAAMG,UAAN,CAAiBtB,aAHlC;AAIE,2BAAiB,KAAKM,eAAL,CAAqBc,CAArB,EAAwBc,IAAxB;AAJnB;AAMIK;AANJ,OAxBJ;AAAA,UAkCEC,iBAAiB,OAAOrB,MAAMG,UAAN,CAAiBe,SAAxB,KAAsC,UAAtC,GACflB,MAAMG,UAAN,CAAiBe,SAAjB,CAA2BA,SAA3B,CADe,GAGfA,SArCJ;AAwCA,aACE;AAAA;AAAA,qBACMlB,MAAMG,UADZ;AAEE,qBAAWC;AAFb;AAIE;AAAA;AAAA,YAAK,KAAKY,YAAV;AACIK;AADJ;AAJF,OADF;AAUD;;;8BAES;AACR,WAAK5B,WAAL,GAAmB,KAAKA,WAAL,CAAiB6B,IAAjB,CAAsB,IAAtB,CAAnB;AACA,WAAKnC,eAAL,GAAuB,KAAKA,eAAL,CAAqBmC,IAArB,CAA0B,IAA1B,CAAvB;AACD;;;yCAEoB;AACnB,WAAKC,OAAL;AACA,WAAK5B,OAAL,GAAe,IAAf;AACA,WAAKc,KAAL,GAAa,EAACC,eAAe,EAAhB,EAAoBC,SAAS,EAA7B,EAAb;AACD;;;gDAE2B;AAC1B,WAAKhB,OAAL,GAAe,IAAf;AACA,WAAKc,KAAL,GAAa,EAACC,eAAe,EAAhB,EAAoBC,SAAS,EAA7B,EAAb;AACD;;AAED;AACA;AACA;;;;kCACc;AACZ,UAAIa,OAAO,IAAX;AACAC,aAAOC,qBAAP,CAA6B,YAAW;AACtCD,eAAOC,qBAAP,CAA6B,YAAW;AACtCD,iBAAOC,qBAAP,CAA6B,YAAW;AACtCF,iBAAK7B,OAAL,GAAe,IAAf;AACA6B,iBAAKG,WAAL;AACD,WAHD;AAID,SALD;AAMD,OAPD;AAQD;;AAED;;;;oCACgB1B,C,EAAGc,I,EAAM;AACvB,UAAIS,OAAO,IAAX;AACA,aAAO,UAASI,CAAT,EAAYC,CAAZ,EAAe;AACpB,YAAIL,KAAKlB,aAAT,EAAwB;AACtBkB,eAAKlB,aAAL,GAAqB,KAArB;AACAkB,eAAKM,WAAL;AACD;AACD,YACEpB,gBAAgBc,KAAKf,KAAL,CAAWC,aAAX,CAAyBqB,KAAzB,EADlB;AAAA,YAGEpB,UAAUa,KAAKf,KAAL,CAAWE,OAAX,CAAmBoB,KAAnB,EAHZ;AAKArB,sBAAcT,CAAd,IAAmB4B,CAAnB;AACA;AACA,YAAI,CAAClB,QAAQV,CAAR,CAAL,EAAiB;AACfU,kBAAQV,CAAR,IAAac,KAAKG,SAAL,CAAec,YAAf,GAA8BH,CAA3C;AACD;AACD;AAHA,aAIK;AACHlB,oBAAQV,CAAR,IAAac,KAAKG,SAAL,CAAec,YAAf,GAA8BjB,KAAKI,mBAAL,CAAyBa,YAApE;AACD;AACDR,aAAKS,QAAL,CAAc;AACZvB,yBAAeA,aADH;AAEZC,mBAASA;AAFG,SAAd;AAID,OAvBD;AAwBD;;;;EA1J+B,iBAAOuB,S;;AA2JxC","file":"adaptive-content-grid.js","sourcesContent":["import preact from 'preact';\r\nimport ResizeSensor from 'resize-sensor--preact';\r\nimport { AdaptiveGrid as DefaultAdaptiveGrid, AdaptiveGridItem } from './adaptive-grid';\r\n\r\nexport { AdaptiveGridItem };\r\n\r\n// wraps content of a grid into an expandable container and content container\r\n// and adds resize sensor on the content container\r\nfunction ContentContainer(props) {\r\n  var paddingTop, paddingBottom;\r\n  if (props.verticalAlign === 'middle') {\r\n    paddingTop = props.contentGap / 2;\r\n    paddingBottom = props.contentGap / 2;\r\n  }\r\n  else if (props.verticalAlign === 'bottom') {\r\n    paddingTop = props.contentGap;\r\n    paddingBottom = 0;\r\n  }\r\n  else {\r\n    paddingTop = 0;\r\n    paddingBottom = props.contentGap;\r\n  }\r\n  return (\r\n    <div\r\n      ref={props.expandableContainerRef}\r\n      style={{\r\n        display: 'inline-block',\r\n        width: '100%',\r\n        position: 'relative',\r\n        paddingTop: (paddingTop + 'px'),\r\n        paddingBottom: (paddingBottom + 'px')\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          display: 'inline-block',\r\n          width: '100%',\r\n          position: 'relative'\r\n        }}\r\n      >\r\n        <ResizeSensor onResize={props.onContentResize} />\r\n        {props.children}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n// This component doesn't really matter\r\nfunction EmptyComponent(props) {\r\n  return <div>{ props.children }</div>;\r\n};\r\n\r\n// this grid composes the regular adaptive grid to add the 'content' functionality\r\nexport class AdaptiveGrid extends preact.Component {\r\n  render() {\r\n    var\r\n      newChildren = this.props.children.map(this.mapChildren),\r\n      style = this.visible ? {} : {\r\n        visibility: 'hidden'\r\n      }\r\n    ;\r\n    return (\r\n      <div style={style}>\r\n        <DefaultAdaptiveGrid\r\n          baseWidth={this.props.baseWidth}\r\n          baseHeight={this.props.baseHeight}\r\n          maxColumns={this.props.maxColumns}\r\n        >\r\n          { newChildren }\r\n        </DefaultAdaptiveGrid>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  mapChildren(child, i) {\r\n    if(!(this.props.baseWidth > 0))\r\n      return child\r\n    ;\r\n    if(!(this.props.baseHeight > 0))\r\n      return child\r\n    ;\r\n    if (child.nodeName !== AdaptiveGridItem)\r\n      return child\r\n    ;\r\n    if (!child.attributes)\r\n      return child\r\n    ;\r\n    if (child.attributes.minHeight !== 'content')\r\n      return child\r\n    ;\r\n    if (typeof child.attributes.content !== 'function')\r\n      return child\r\n    ;\r\n    if (this.needsResizing === undefined) {\r\n      this.needsResizing = true;\r\n      this.visible = false;\r\n    }\r\n    var\r\n      containerHeight = this.state.contentHeight[i] + this.state.padding[i]\r\n    ,\r\n      minHeight = (containerHeight || this.props.baseHeight)\r\n    ,\r\n      fullHeight = Math.ceil(minHeight / this.props.baseHeight) * this.props.baseHeight\r\n    ,\r\n      refs = {}\r\n    ,\r\n      containerRef = function(element) {\r\n        refs.container = element\r\n      }\r\n    ,\r\n      expandableContainerRef = function(element) {\r\n        refs.expandableContainer = element\r\n      }\r\n    ,\r\n      content = child.attributes.content(\r\n        EmptyComponent\r\n      )\r\n    ,\r\n      contentChildren = content.children\r\n    ,\r\n      container = (\r\n        <ContentContainer\r\n          expandableContainerRef={expandableContainerRef}\r\n          contentGap={fullHeight - minHeight}\r\n          verticalAlign={child.attributes.verticalAlign}\r\n          onContentResize={this.onContentResize(i, refs)}\r\n        >\r\n          { contentChildren }\r\n        </ContentContainer>\r\n      )\r\n    ,\r\n      finalContainer = typeof child.attributes.container === 'function' ? (\r\n        child.attributes.container(container)\r\n      ) : (\r\n        container\r\n      )\r\n    ;\r\n    return (\r\n      <AdaptiveGridItem\r\n        {...child.attributes}\r\n        minHeight={minHeight}\r\n      >\r\n        <div ref={containerRef}>\r\n          { finalContainer }\r\n        </div>\r\n      </AdaptiveGridItem>\r\n    )\r\n  }\r\n\r\n  bindAll() {\r\n    this.mapChildren = this.mapChildren.bind(this);\r\n    this.onContentResize = this.onContentResize.bind(this);\r\n  }\r\n\r\n  componentWillMount() {\r\n    this.bindAll();\r\n    this.visible = true;\r\n    this.state = {contentHeight: [], padding: []};\r\n  }\r\n\r\n  componentWillReceiveProps() {\r\n    this.visible = true;\r\n    this.state = {contentHeight: [], padding: []};\r\n  }\r\n\r\n  // to avoid seeing overlap between grid items, we defer\r\n  // making grid visible by a few frames so that it has time\r\n  // to change sizes\r\n  makeVisible() {\r\n    var self = this;\r\n    window.requestAnimationFrame(function() {\r\n      window.requestAnimationFrame(function() {\r\n        window.requestAnimationFrame(function() {\r\n          self.visible = true;\r\n          self.forceUpdate();\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  // callback for when the content for an item is resized\r\n  onContentResize(i, refs) {\r\n    var self = this;\r\n    return function(w, h) {\r\n      if (self.needsResizing) {\r\n        self.needsResizing = false;\r\n        self.makeVisible();\r\n      }\r\n      var\r\n        contentHeight = self.state.contentHeight.slice()\r\n      ,\r\n        padding = self.state.padding.slice()\r\n      ;\r\n      contentHeight[i] = h;\r\n      // at initial render, the padding will be container - content\r\n      if (!padding[i]) {\r\n        padding[i] = refs.container.clientHeight - h;\r\n      }\r\n      // at all further renders, the padding will be container - expanded content\r\n      else {\r\n        padding[i] = refs.container.clientHeight - refs.expandableContainer.clientHeight;\r\n      }\r\n      self.setState({\r\n        contentHeight: contentHeight,\r\n        padding: padding\r\n      });\r\n    };\r\n  }\r\n};"]}