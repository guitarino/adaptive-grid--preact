{"version":3,"sources":["../src/adaptive-grid.jsx"],"names":["AdaptiveGridItem","props","childStyle","children","Component","isFilled","colStart","rowStart","colEnd","rowEnd","arr","forEach","borders","colStart2","rowStart2","colEnd2","rowEnd2","doFill","push","AdaptiveGrid","onResize","bind","state","width","setState","availableWidth","child","nodeName","gridStyle","overflow","maxHeight","baseWidth","baseHeight","totalColumns","Math","floor","colWidth","childrenSizes","map","height","attributes","minWidth","minHeight","cols","min","ceil","rows","remainingElements","slice","call","remainingElementsIds","Object","keys","childrenCoords","row","boundaries","length","col","elId","childId","splice","i","position","left","top","edge"],"mappings":";;;;;;;;;;;AAMA;;;;AACA;;;;AAEA;;;;;;;;+eATA;;;;;;IAWaA,gB,WAAAA,gB;;;;;;;;;;;6BACF;AACP,aACE;AAAA;AAAA,UAAK,SAAM,kBAAX,EAA8B,OAAO,KAAKC,KAAL,CAAWC,UAAhD;AACG,aAAKD,KAAL,CAAWE;AADd,OADF;AAKD;;;;EAPmC,iBAAOC,S;;AAQ5C;;AAED,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,QAA5B,EAAsCC,MAAtC,EAA8CC,MAA9C,EAAsDC,GAAtD,EAA2D;AACzD,MAAIL,WAAW,KAAf;AACAK,MAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AAAA,kCACwBA,OADxB;AAAA,QAClBC,SADkB;AAAA,QACPC,SADO;AAAA,QACIC,OADJ;AAAA,QACaC,OADb;;AAEvB,QAAIV,WAAWS,OAAX,IAAsBP,SAASK,SAA/B,IACFG,UAAUT,QADR,IACoBO,YAAYL,MADpC,EAC6C;AAC3CJ,iBAAW,IAAX;AACA,aAAO,KAAP;AACD;AACF,GAPD;AAQA,SAAOA,QAAP;AACD;;AAED,SAASY,MAAT,CAAgBX,QAAhB,EAA0BC,QAA1B,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,GAApD,EAAyD;AACvDA,MAAIQ,IAAJ,CAAS,CAACZ,QAAD,EAAWC,QAAX,EAAqBC,MAArB,EAA6BC,MAA7B,CAAT;AACD;;IAEYU,Y,WAAAA,Y;;;AACX,0BAAc;AAAA;;AAAA;;AAEZ,WAAKC,QAAL,GAAgB,OAAKA,QAAL,CAAcC,IAAd,QAAhB;AACA,WAAKC,KAAL,GAAa,EAACC,OAAO,CAAR,EAAb;AAHY;AAIb;;;;6BAEQA,K,EAAO;AACd,WAAKC,QAAL,CAAc,EAACD,OAAOA,KAAR,EAAd;AACD;;;6BAEQ;AACP,UAAIE,iBAAiB,KAAKH,KAAL,CAAWC,KAAhC;AACA,UAAIpB,WAAW,EAAf;AACA,WAAKF,KAAL,CAAWE,QAAX,CAAoBQ,OAApB,CAA4B,UAACe,KAAD,EAAW;AACrC,YAAGA,MAAMC,QAAN,KAAmB3B,gBAAtB,EAAwC;AACtCG,mBAASe,IAAT,CAAcQ,KAAd;AACD;AACF,OAJD;AAKA,UAAIE,YAAY,EAAEC,UAAU,SAAZ,EAAhB;AACA,UAAIC,YAAY,CAAhB;AACA,UAAIL,iBAAiB,CAArB,EAAwB;AACtB,YAAIM,YAAY,KAAK9B,KAAL,CAAW8B,SAA3B;AACA,YAAIC,aAAa,KAAK/B,KAAL,CAAW+B,UAA5B;AACA,YAAIC,eAAeC,KAAKC,KAAL,CAAWV,iBAAiBM,SAA5B,CAAnB;AACA,YAAIK,WAAWX,iBAAiBQ,YAAhC;AACA,YAAII,gBAAgBlC,SAASmC,GAAT,CAAa,UAACZ,KAAD,EAAW;AAC1C,cAAIH,QAAQQ,SAAZ;AACA,cAAIQ,SAASP,UAAb;AACA,cAAGN,MAAMc,UAAT,EAAqB;AACnB,gBAAGd,MAAMc,UAAN,CAAiBC,QAApB,EAA8B;AAC5BlB,sBAAQG,MAAMc,UAAN,CAAiBC,QAAzB;AACD;AACD,gBAAGf,MAAMc,UAAN,CAAiBE,SAApB,EAA+B;AAC7BH,uBAASb,MAAMc,UAAN,CAAiBE,SAA1B;AACD;AACF;AACD,iBAAO;AACLC,kBAAMT,KAAKU,GAAL,CAASX,YAAT,EAAuBC,KAAKW,IAAL,CAAUtB,QAAQQ,SAAlB,CAAvB,CADD;AAELe,kBAAMZ,KAAKW,IAAL,CAAUN,SAASP,UAAnB;AAFD,WAAP;AAID,SAfmB,CAApB;AAgBA,YAAIe,oBAAoB,GAAGC,KAAH,CAASC,IAAT,CAAc9C,QAAd,CAAxB;AACA,YAAI+C,uBAAuBC,OAAOC,IAAP,CAAYjD,QAAZ,CAA3B;AACA,YAAIkD,iBAAiB,EAArB;AACA,YAAIC,MAAM,CAAV;AACA,YAAIC,aAAa,EAAjB;AACA,eAAMR,kBAAkBS,MAAxB,EAAgC;AAC9B,eAAI,IAAIC,MAAM,CAAd,EAAiBA,MAAMxB,YAAvB,EAAqCwB,KAArC,EAA4C;AAC1C,iBAAI,IAAIC,OAAO,CAAf,EAAkBA,OAAOX,kBAAkBS,MAA3C,EAAmDE,MAAnD,EAA2D;AACzD,kBAAIC,UAAUT,qBAAqBQ,IAArB,CAAd;AACA,kBAAIf,OAAON,cAAcsB,OAAd,EAAuBhB,IAAlC;AACA,kBAAIG,OAAOT,cAAcsB,OAAd,EAAuBb,IAAlC;AACA,kBAAGW,MAAMd,IAAN,IAAcV,YAAjB,EAA+B;AAC7B,oBAAG,CAAC5B,SAASoD,GAAT,EAAcH,GAAd,EAAmBG,MAAMd,IAAzB,EAA+BW,MAAMR,IAArC,EAA2CS,UAA3C,CAAJ,EAA4D;AAC1DR,oCAAkBa,MAAlB,CAAyBF,IAAzB,EAA+B,CAA/B;AACAR,uCAAqBU,MAArB,CAA4BF,IAA5B,EAAkC,CAAlC;AACAA;AACAL,iCAAeM,OAAf,IAA0B,CAACF,GAAD,EAAMH,GAAN,CAA1B;AACArC,yBAAOwC,GAAP,EAAYH,GAAZ,EAAiBG,MAAMd,IAAvB,EAA6BW,MAAMR,IAAnC,EAAyCS,UAAzC;AACA;AACD;AACF;AACF;AACF;AACDD;AACD;AACDnD,iBAASQ,OAAT,CAAiB,UAACe,KAAD,EAAQmC,CAAR,EAAc;AAC7B,cAAI,CAACnC,MAAMc,UAAX,EAAuB;AACrBd,kBAAMc,UAAN,GAAmB,EAAnB;AACD;AACDd,gBAAMc,UAAN,CAAiBtC,UAAjB,GAA8B;AAC5B4D,sBAAU,UADkB;AAE5BC,kBAAMV,eAAeQ,CAAf,EAAkB,CAAlB,IAAuBzB,QAAvB,GAAkC,IAFZ;AAG5B4B,iBAAKX,eAAeQ,CAAf,EAAkB,CAAlB,IAAuB7B,UAAvB,GAAoC,IAHb;AAI5BT,mBAAOc,cAAcwB,CAAd,EAAiBlB,IAAjB,GAAwBP,QAAxB,GAAmC,IAJd;AAK5BG,oBAAQF,cAAcwB,CAAd,EAAiBf,IAAjB,GAAwBd,UAAxB,GAAqC;AALjB,WAA9B;AAOA,cAAIiC,OAAO,CAACZ,eAAeQ,CAAf,EAAkB,CAAlB,IAAuBxB,cAAcwB,CAAd,EAAiBf,IAAzC,IAAiDd,UAA5D;AACA,cAAIiC,OAAOnC,SAAX,EAAsBA,YAAYmC,IAAZ;AACvB,SAbD;AAcArC,kBAAUW,MAAV,GAAmBT,SAAnB;AACD;AACD,aACE;AAAA;AAAA,UAAK,SAAM,cAAX,EAA0B,OAAQF,SAAlC;AACE,2DAAc,UAAW,KAAKR,QAA9B,GADF;AAEIjB;AAFJ,OADF;AAMD;;;;EAzF+B,iBAAOC,S","file":"adaptive-grid.js","sourcesContent":["/**\r\n * @license MIT\r\n * @copyright Kirill Shestakov 2017\r\n * @see https://github.com/guitarino/adaptive-grid--preact/\r\n */\r\n\r\nimport preact from 'preact';\r\nimport ResizeSensor from 'resize-sensor--preact';\r\n\r\nimport './adaptive-grid.css';\r\n\r\nexport class AdaptiveGridItem extends preact.Component {\r\n  render() {\r\n    return (\r\n      <div class=\"AdaptiveGridItem\" style={this.props.childStyle}>\r\n        {this.props.children}\r\n      </div>\r\n    )\r\n  }\r\n};\r\n\r\nfunction isFilled(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  var isFilled = false;\r\n  arr.forEach((borders) => {\r\n    var [colStart2, rowStart2, colEnd2, rowEnd2] = borders;\r\n    if (colStart < colEnd2 && colEnd > colStart2 &&\r\n      rowEnd2 > rowStart && rowStart2 < rowEnd ) {\r\n      isFilled = true;\r\n      return false;\r\n    }\r\n  });\r\n  return isFilled;\r\n}\r\n\r\nfunction doFill(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  arr.push([colStart, rowStart, colEnd, rowEnd]);\r\n}\r\n\r\nexport class AdaptiveGrid extends preact.Component {\r\n  constructor() {\r\n    super();\r\n    this.onResize = this.onResize.bind(this);\r\n    this.state = {width: 0};\r\n  }\r\n  \r\n  onResize(width) {\r\n    this.setState({width: width});\r\n  }\r\n\r\n  render() {\r\n    var availableWidth = this.state.width;\r\n    var children = [];\r\n    this.props.children.forEach((child) => {\r\n      if(child.nodeName === AdaptiveGridItem) {\r\n        children.push(child);\r\n      }\r\n    });\r\n    var gridStyle = { overflow: 'visible' };\r\n    var maxHeight = 0;\r\n    if (availableWidth > 0) {\r\n      var baseWidth = this.props.baseWidth;\r\n      var baseHeight = this.props.baseHeight;\r\n      var totalColumns = Math.floor(availableWidth / baseWidth);\r\n      var colWidth = availableWidth / totalColumns;\r\n      var childrenSizes = children.map((child) => {\r\n        var width = baseWidth;\r\n        var height = baseHeight;\r\n        if(child.attributes) {\r\n          if(child.attributes.minWidth) {\r\n            width = child.attributes.minWidth;\r\n          }\r\n          if(child.attributes.minHeight) {\r\n            height = child.attributes.minHeight;\r\n          }\r\n        }\r\n        return {\r\n          cols: Math.min(totalColumns, Math.ceil(width / baseWidth)),\r\n          rows: Math.ceil(height / baseHeight)\r\n        };\r\n      });\r\n      var remainingElements = [].slice.call(children);\r\n      var remainingElementsIds = Object.keys(children);\r\n      var childrenCoords = [];\r\n      var row = 0;\r\n      var boundaries = [];\r\n      while(remainingElements.length) {\r\n        for(var col = 0; col < totalColumns; col++) {\r\n          for(var elId = 0; elId < remainingElements.length; elId++) {\r\n            var childId = remainingElementsIds[elId];\r\n            var cols = childrenSizes[childId].cols;\r\n            var rows = childrenSizes[childId].rows;\r\n            if(col + cols <= totalColumns) {\r\n              if(!isFilled(col, row, col + cols, row + rows, boundaries)) {\r\n                remainingElements.splice(elId, 1);\r\n                remainingElementsIds.splice(elId, 1);\r\n                elId--;\r\n                childrenCoords[childId] = [col, row];\r\n                doFill(col, row, col + cols, row + rows, boundaries);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        row++;\r\n      }\r\n      children.forEach((child, i) => {\r\n        if (!child.attributes) {\r\n          child.attributes = {};\r\n        }\r\n        child.attributes.childStyle = {\r\n          position: 'absolute',\r\n          left: childrenCoords[i][0] * colWidth + 'px',\r\n          top: childrenCoords[i][1] * baseHeight + 'px',\r\n          width: childrenSizes[i].cols * colWidth + 'px',\r\n          height: childrenSizes[i].rows * baseHeight + 'px'\r\n        };\r\n        var edge = (childrenCoords[i][1] + childrenSizes[i].rows) * baseHeight;\r\n        if (edge > maxHeight) maxHeight = edge;\r\n      });\r\n      gridStyle.height = maxHeight;\r\n    }\r\n    return (\r\n      <div class='AdaptiveGrid' style={ gridStyle }>\r\n        <ResizeSensor onResize={ this.onResize } />\r\n        { children }\r\n      </div>\r\n    );\r\n  }\r\n}"]}