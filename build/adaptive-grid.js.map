{"version":3,"sources":["../src/adaptive-grid.jsx"],"names":["AdaptiveGridItem","props","childStyle","children","AdaptiveGrid","state","width","onResize","bind","getFilteredChildren","gridStyle","overflow","position","canCalculate","totalColumns","getTotalColumns","colWidth","getColWidth","sizes","getItemSizes","coords","getItemCoordinates","applyItemStyles","height","getGridMaxHeight","visibility","baseWidth","baseHeight","console","error","setState","forEach","child","nodeName","push","maxColumns","Infinity","Math","max","min","floor","map","attributes","minWidth","minHeight","ceil","remainingElements","slice","call","remainingElementsIds","Object","keys","row","boundaries","length","col","elId","childId","cols","rows","isFilled","doFill","splice","i","left","top","maxRow","Component","colStart","rowStart","colEnd","rowEnd","arr","borders","colStart2","rowStart2","colEnd2","rowEnd2"],"mappings":"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","file":"adaptive-grid.js","sourcesContent":["/**\r\n * @license MIT\r\n * @copyright Kirill Shestakov 2017\r\n * @see https://github.com/guitarino/adaptive-grid--preact/\r\n */\r\n\r\nimport preact from 'preact';\r\nimport ResizeSensor from 'resize-sensor--preact';\r\n\r\nexport function AdaptiveGridItem(props) {\r\n  return (\r\n    <div class=\"AdaptiveGridItem\" style={props.childStyle}>\r\n      {props.children}\r\n    </div>\r\n  )\r\n};\r\n\r\nexport class AdaptiveGrid extends preact.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = { width: 0 };\r\n    this.onResize = this.onResize.bind(this);\r\n  }\r\n\r\n  render() {\r\n    var children = this.getFilteredChildren();\r\n    var gridStyle = {\r\n      overflow: 'visible',\r\n      position: 'relative'\r\n    };\r\n    if (this.canCalculate()) {\r\n      var totalColumns = this.getTotalColumns();\r\n      var colWidth = this.getColWidth(totalColumns);\r\n      var sizes = this.getItemSizes(children, totalColumns);\r\n      var coords = this.getItemCoordinates(children, sizes, totalColumns);\r\n      children = this.applyItemStyles(children, colWidth, sizes, coords);\r\n      gridStyle.height = this.getGridMaxHeight(children, sizes, coords) + 'px';\r\n    }\r\n    else {\r\n      gridStyle.visibility = 'hidden';\r\n      if (!(\r\n        this.props.baseWidth > 0 &&\r\n        this.props.baseHeight > 0\r\n      )) {\r\n        console.error('Base width and base height should be provided and be positive');\r\n      }\r\n    }\r\n    return (\r\n      <div class='AdaptiveGrid' style={ gridStyle }>\r\n        <ResizeSensor onResize={ this.onResize } />\r\n        { children }\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  // callback from resize-sensor\r\n  onResize(width) {\r\n    if (this.state.width !== width) {\r\n      this.setState({width: width});\r\n    }\r\n  }\r\n\r\n  // this is to ignore children that are not AdaptiveGridItem\r\n  getFilteredChildren() {\r\n    var children = [];\r\n    this.props.children.forEach((child) => {\r\n      if(child.nodeName === AdaptiveGridItem) {\r\n        children.push(child);\r\n      }\r\n    });\r\n    return children;\r\n  }\r\n\r\n  // if calculation can happen without error, returns true\r\n  canCalculate() {\r\n    return (\r\n      this.state.width > 0 &&\r\n      this.props.baseWidth > 0 &&\r\n      this.props.baseHeight > 0\r\n    );\r\n  }\r\n\r\n  // also account for max columns\r\n  getTotalColumns() {\r\n    let maxColumns = this.props.maxColumns ? this.props.maxColumns : Infinity;\r\n    return Math.max(1, Math.min(maxColumns, Math.floor(this.state.width / this.props.baseWidth)));\r\n  }\r\n\r\n  getColWidth(totalColumns) {\r\n    return this.state.width / totalColumns;\r\n  }\r\n\r\n  getItemSizes(children, totalColumns) {\r\n    return children.map((child) => {\r\n      var width = this.props.baseWidth;\r\n      var height = this.props.baseHeight;\r\n      if(child.attributes) {\r\n        if(child.attributes.minWidth) {\r\n          width = child.attributes.minWidth;\r\n        }\r\n        if(child.attributes.minHeight) {\r\n          height = child.attributes.minHeight;\r\n        }\r\n      }\r\n      return [\r\n        Math.min(totalColumns, Math.ceil(width / this.props.baseWidth)),\r\n        Math.ceil(height / this.props.baseHeight)\r\n      ];\r\n    });\r\n  }\r\n\r\n  getItemCoordinates(children, sizes, totalColumns) {\r\n    var remainingElements = [].slice.call(children);\r\n    // remainingElementsIds is in sync with remainingElements so that\r\n    // we don't have to search for indeces every time\r\n    var remainingElementsIds = Object.keys(children);\r\n    var coords = [];\r\n    var row = 0;\r\n    var boundaries = []; // array for boundaries of current grid items\r\n    // filling up the grid and removing remainingElements until none left\r\n    while(remainingElements.length) {\r\n      for(var col = 0; col < totalColumns; col++) {\r\n        for(var elId = 0; elId < remainingElements.length; elId++) {\r\n          var childId = remainingElementsIds[elId];\r\n          var [cols, rows] = sizes[childId];\r\n          // if not exceeding the boundary\r\n          if(col + cols <= totalColumns) {\r\n            // and if other items are not in the way\r\n            if(!isFilled(col, row, col + cols, row + rows, boundaries)) {\r\n              // then the current item can claim those coordinates\r\n              coords[childId] = [col, row];\r\n              // and, don't forget to update the filled space\r\n              doFill(col, row, col + cols, row + rows, boundaries);\r\n              // now, there's 1 less item remaining\r\n              remainingElements.splice(elId, 1);\r\n              remainingElementsIds.splice(elId, 1);\r\n              elId--; // since we removed an element, we gotta go back by 1 id\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      row++;\r\n    }\r\n    return coords;\r\n  }\r\n\r\n  applyItemStyles(children, colWidth, sizes, coords) {\r\n    return children.map((child, i) => (\r\n      <AdaptiveGridItem\r\n        {...child.attributes}\r\n        childStyle={{\r\n          position: 'absolute',\r\n          left: coords[i][0] * colWidth + 'px',\r\n          top: coords[i][1] * this.props.baseHeight + 'px',\r\n          width: sizes[i][0] * colWidth + 'px',\r\n          height: sizes[i][1] * this.props.baseHeight + 'px'\r\n        }}\r\n      >\r\n        {child.children}\r\n      </AdaptiveGridItem>\r\n    ));\r\n  }\r\n\r\n  getGridMaxHeight(children, sizes, coords) {\r\n    var maxRow = 0;\r\n    children.forEach((child, i) => {\r\n      var [col, row] = coords[i];\r\n      var [cols, rows] = sizes[i];\r\n      if (row + rows > maxRow) {\r\n        maxRow = row + rows;\r\n      }\r\n    });\r\n    return maxRow * this.props.baseHeight;\r\n  }\r\n}\r\n\r\n// checks if the provided coordinates and sizes for an item\r\n// will overlap with currently placed items\r\nfunction isFilled(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  var isFilled = false;\r\n  arr.forEach((borders) => {\r\n    var [colStart2, rowStart2, colEnd2, rowEnd2] = borders;\r\n    if (colStart < colEnd2 && colEnd > colStart2 &&\r\n      rowEnd2 > rowStart && rowStart2 < rowEnd ) {\r\n      isFilled = true;\r\n      return false;\r\n    }\r\n  });\r\n  return isFilled;\r\n}\r\n\r\n// adds provided coordinates and sizes as a currently placed item\r\nfunction doFill(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  arr.push([colStart, rowStart, colEnd, rowEnd]);\r\n}"]}