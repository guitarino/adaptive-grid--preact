{"version":3,"sources":["../src/adaptive-grid.jsx"],"names":["AdaptiveGridItem","props","childStyle","children","AdaptiveGrid","state","width","onResize","bind","getFilteredChildren","gridStyle","overflow","canCalculate","totalColumns","getTotalColumns","colWidth","getColWidth","sizes","getItemSizes","coords","getItemCoordinates","applyItemStyles","height","getGridMaxHeight","visibility","baseWidth","baseHeight","console","error","setState","forEach","child","nodeName","push","Math","floor","map","attributes","minWidth","minHeight","min","ceil","remainingElements","slice","call","remainingElementsIds","Object","keys","row","boundaries","length","col","elId","childId","cols","rows","isFilled","doFill","splice","i","position","left","top","maxRow","Component","colStart","rowStart","colEnd","rowEnd","arr","borders","colStart2","rowStart2","colEnd2","rowEnd2"],"mappings":"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","file":"adaptive-grid.js","sourcesContent":["/**\r\n * @license MIT\r\n * @copyright Kirill Shestakov 2017\r\n * @see https://github.com/guitarino/adaptive-grid--preact/\r\n */\r\n\r\nimport preact from 'preact';\r\nimport ResizeSensor from 'resize-sensor--preact';\r\n\r\nexport function AdaptiveGridItem(props) {\r\n  return (\r\n    <div class=\"AdaptiveGridItem\" style={props.childStyle}>\r\n      {props.children}\r\n    </div>\r\n  )\r\n};\r\n\r\nexport class AdaptiveGrid extends preact.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = { width: 0 };\r\n    this.onResize = this.onResize.bind(this);\r\n  }\r\n\r\n  render() {\r\n    var children = this.getFilteredChildren();\r\n    var gridStyle = { overflow: 'visible' };\r\n    if (this.canCalculate()) {\r\n      var totalColumns = this.getTotalColumns();\r\n      var colWidth = this.getColWidth(totalColumns);\r\n      var sizes = this.getItemSizes(children, totalColumns);\r\n      var coords = this.getItemCoordinates(children, sizes, totalColumns);\r\n      this.applyItemStyles(children, colWidth, sizes, coords);\r\n      gridStyle.height = this.getGridMaxHeight(children, sizes, coords) + 'px';\r\n    }\r\n    else {\r\n      gridStyle.visibility = 'hidden';\r\n      if (!(\r\n        this.props.baseWidth > 0 &&\r\n        this.props.baseHeight > 0\r\n      )) {\r\n        console.error('Base width and base height should be provided and be positive');\r\n      }\r\n    }\r\n    return (\r\n      <div class='AdaptiveGrid' style={ gridStyle }>\r\n        <ResizeSensor onResize={ this.onResize } />\r\n        { children }\r\n      </div>\r\n    );\r\n  }\r\n  \r\n  // callback from resize-sensor\r\n  onResize(width) {\r\n    if (this.state.width !== width) {\r\n      this.setState({width: width});\r\n    }\r\n  }\r\n\r\n  // this is to ignore children that are not AdaptiveGridItem\r\n  getFilteredChildren() {\r\n    var children = [];\r\n    this.props.children.forEach((child) => {\r\n      if(child.nodeName === AdaptiveGridItem) {\r\n        children.push(child);\r\n      }\r\n    });\r\n    return children;\r\n  }\r\n\r\n  // if calculation can happen without error, returns true\r\n  canCalculate() {\r\n    return (\r\n      this.state.width > 0 &&\r\n      this.props.baseWidth > 0 &&\r\n      this.props.baseHeight > 0\r\n    );\r\n  }\r\n\r\n  // if calculation can happen without error, returns true\r\n  getTotalColumns() {\r\n    return Math.floor(this.state.width / this.props.baseWidth);\r\n  }\r\n\r\n  getColWidth(totalColumns) {\r\n    return this.state.width / totalColumns;\r\n  }\r\n\r\n  getItemSizes(children, totalColumns) {\r\n    return children.map((child) => {\r\n      var width = this.props.baseWidth;\r\n      var height = this.props.baseHeight;\r\n      if(child.attributes) {\r\n        if(child.attributes.minWidth) {\r\n          width = child.attributes.minWidth;\r\n        }\r\n        if(child.attributes.minHeight) {\r\n          height = child.attributes.minHeight;\r\n        }\r\n      }\r\n      return [\r\n        Math.min(totalColumns, Math.ceil(width / this.props.baseWidth)),\r\n        Math.ceil(height / this.props.baseHeight)\r\n      ];\r\n    });\r\n  }\r\n\r\n  getItemCoordinates(children, sizes, totalColumns) {\r\n    var remainingElements = [].slice.call(children);\r\n    // remainingElementsIds is in sync with remainingElements so that\r\n    // we don't have to search for indeces every time\r\n    var remainingElementsIds = Object.keys(children);\r\n    var coords = [];\r\n    var row = 0;\r\n    var boundaries = []; // array for boundaries of current grid items\r\n    // filling up the grid and removing remainingElements until none left\r\n    while(remainingElements.length) {\r\n      for(var col = 0; col < totalColumns; col++) {\r\n        for(var elId = 0; elId < remainingElements.length; elId++) {\r\n          var childId = remainingElementsIds[elId];\r\n          var [cols, rows] = sizes[childId];\r\n          // if not exceeding the boundary\r\n          if(col + cols <= totalColumns) {\r\n            // and if other items are not in the way\r\n            if(!isFilled(col, row, col + cols, row + rows, boundaries)) {\r\n              // then the current item can claim those coordinates\r\n              coords[childId] = [col, row];\r\n              // and, don't forget to update the filled space\r\n              doFill(col, row, col + cols, row + rows, boundaries);\r\n              // now, there's 1 less item remaining\r\n              remainingElements.splice(elId, 1);\r\n              remainingElementsIds.splice(elId, 1);\r\n              elId--; // since we removed an element, we gotta go back by 1 id\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      row++;\r\n    }\r\n    return coords;\r\n  }\r\n\r\n  applyItemStyles(children, colWidth, sizes, coords) {\r\n    children.forEach((child, i) => {\r\n      if (!child.attributes) {\r\n        child.attributes = {};\r\n      }\r\n      child.attributes.childStyle = {\r\n        position: 'absolute',\r\n        left: coords[i][0] * colWidth + 'px',\r\n        top: coords[i][1] * this.props.baseHeight + 'px',\r\n        width: sizes[i][0] * colWidth + 'px',\r\n        height: sizes[i][1] * this.props.baseHeight + 'px'\r\n      };\r\n    });\r\n  }\r\n\r\n  getGridMaxHeight(children, sizes, coords) {\r\n    var maxRow = 0;\r\n    children.forEach((child, i) => {\r\n      var [col, row] = coords[i];\r\n      var [cols, rows] = sizes[i];\r\n      if (row + rows > maxRow) {\r\n        maxRow = row + rows;\r\n      }\r\n    });\r\n    return maxRow * this.props.baseHeight;\r\n  }\r\n}\r\n\r\n// checks if the provided coordinates and sizes for an item\r\n// will overlap with currently placed items\r\nfunction isFilled(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  var isFilled = false;\r\n  arr.forEach((borders) => {\r\n    var [colStart2, rowStart2, colEnd2, rowEnd2] = borders;\r\n    if (colStart < colEnd2 && colEnd > colStart2 &&\r\n      rowEnd2 > rowStart && rowStart2 < rowEnd ) {\r\n      isFilled = true;\r\n      return false;\r\n    }\r\n  });\r\n  return isFilled;\r\n}\r\n\r\n// adds provided coordinates and sizes as a currently placed item\r\nfunction doFill(colStart, rowStart, colEnd, rowEnd, arr) {\r\n  arr.push([colStart, rowStart, colEnd, rowEnd]);\r\n}"]}